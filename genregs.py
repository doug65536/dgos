#!/usr/bin/env python
import sys
import io

debugging = False


def debug(message):
	if debugging:
		sys.stderr.write(message + '\n')


def define(prefix_name, name, suffix, max_len):
	if name is not None or suffix is not None:
		f = '#define {}_{}{}'.format(prefix_name, name, suffix)
	else:
		f = '#define {}'.format(prefix_name)
	return ('{:<' + str(max_len) + '}').format(f)


def print_comment(comment):
	if not comment is None:
		print('\n// {}'.format(comment))


def print_line(line):
	if len(line) >= 80:
		tokens = line.split(' ')

		# Force the first two tokens onto the same line
		tokens[0] = tokens[0] + ' ' + tokens[1]
		del tokens[1]

		index = len(tokens) - 1
		while index > 0:
			if len(tokens[index-1]) + 1 + len(tokens[index]) <= 75:
				tokens[index-1] = tokens[index-1] + ' ' + tokens[index]
				del tokens[index]
			index = index - 1

		index = 0
		while index < len(tokens):
			tokens[index] = tokens[index].strip()
			index = index + 1

		line = ' \\\n    '.join(tokens)

	print(line)


def write_one_prefix(prefix_data):
	suffix = ''
	cast = ''
	max_len = 0
	prefix = prefix_data['name']
	prefix_comment = prefix_data['comment']
	prefix_value = prefix_data['value']
	items = prefix_data['items']

	for item in items:
		w = len(item['name'])
		n = 8 + len(prefix) + 1 + w + 1 + 8 + 1
		if max_len < n:
			max_len = n
		if item['bit'] + item['bits'] > 32:
			suffix = 'L'
			cast = 'uint64_t'

	if prefix_comment is not None:
		print('')
		print('//')
		print_line('// {}: {}'.format(prefix, prefix_comment))
	else:
		print_line('\n// {0}'.format(prefix))

	if prefix_value is not None:
		print_line('{0} {1}'.format(
			define(prefix, None, None, max_len),
			prefix_value
		))

	if len(items):
		print('')

	for item in items:
		print_comment(item['comment'])

		print_line('{0} {1}'.format(
			define(prefix, item['name'], '_BIT', max_len),
			item['bit']
		))

	if len(items):
		print('')

	for item in items:
		print_comment(item['comment'])

		print_line('{0} {1}'.format(
			define(prefix, item['name'], '_BITS', max_len),
			item['bits']
		))

	for item in items:
		print_comment(item['comment'])

		print_line('{0} ((1U{3} << {1}_{2}_BITS)-1)'.format(
			define(prefix, item['name'], '_MASK', max_len),
			prefix, item['name'], suffix
		))

	for item in items:
		print_comment(item['comment'])

		print_line('{0} ({1}_{2}_MASK << {1}_{2}_BIT)'.format(
			define(prefix, item['name'], '', max_len),
			prefix, item['name']
		))

	if len(items):
		print('')

	for item in items:
		print_comment(item['comment'])

		print_line('{0} ({3}(n) << {1}_{2}_BIT)'.format(
			define(prefix, item['name'], '_n(n)', max_len),
			prefix, item['name'], cast
		))

	if len(items):
		print('')

	for item in items:
		print_comment(item['comment'])

		print_line('{0} (((n) >> {1}_{2}_BIT) & {1}_{2}_MASK)'.format(
			define(prefix, item['name'], '_GET(n)', max_len),
			prefix, item['name']
		))

	if len(items):
		print('')

	for item in items:
		print_comment(item['comment'])

		print_line('{0} ((r) = ((r) & ~{1}_{2}) | {1}_{2}_n((n)))'.format(
			define(prefix, item['name'], '_SET(r,n)', max_len),
			prefix, item['name']
		))


def write_declarations(prefixes):
	for prefix in prefixes:
		write_one_prefix(prefix)


def process_input():
	print('// THIS FILE IS AUTOMATICALLY GENERATED')
	if len(sys.argv) > 1 and sys.argv[1] != '-':
		input_file_path = sys.argv[1]
		src_path = sys.argv[2]
		stream = io.open(input_file_path, 'r')

		input_file_parts = input_file_path.split('/')
		src_parts = src_path.split('/')
		while len(input_file_parts) > 0 and \
				len(src_parts) > 0 and \
				input_file_parts[0] == src_parts[0]:
			input_file_parts.pop(0)
			src_parts.pop(0)

		relative_path = '/'.join(input_file_parts)

		print('// from {}'.format(relative_path))
	else:
		stream = sys.stdin

	prefixes = []
	items = None

	while True:
		line = stream.readline()

		if not line:
			break

		line = line.strip()

		if line == '' or line[0] == '#':
			continue

		if line.startswith('-- '):
			prefix = line[3:].strip()

			# Split <name>[=<value>][ [<comment>]]

			pack = prefix.split(' ', 1)

			prefix = pack[0]

			prefix_comment = None
			prefix_value = None
			if len(pack) > 1:
				prefix_comment = pack[1]

			pack = prefix.split('=', 1)
			prefix = pack[0]
			if len(pack) > 1:
				prefix_value = pack[1]

			items = []

			debug('Starting bitfield {}'.format(prefix))

			prefixes.append({
				'name': prefix,
				'comment': prefix_comment,
				'value': prefix_value,
				'items': items
			})

			continue

		if not prefix:
			continue

		pack = line.split(' ', 2)
		if len(pack) > 2:
			bits, name, comment = pack
		else:
			bits, name = pack
			comment = None

		bit_range = bits.split(':')
		hi = int(bit_range[0])
		if len(bit_range) == 2:
			lo = int(bit_range[1])
		else:
			lo = int(bit_range[0])

		width = hi - lo + 1

		items.append({
			'bit': lo,
			'bits': width,
			'name': name,
			'comment': comment
		})

	write_declarations(prefixes)
	print('')

process_input()
